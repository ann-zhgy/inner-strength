# 平衡二叉树

> 任意节点的子树的高度差都小于等于1

## 一、二叉搜索树搜索元素的复杂度分析

![Binary Tree](https://i.loli.net/2020/10/09/UR8htEdV6FNeTyP.jpg)

1. 如果要查找14、16……需要三次操作，如果要查找17，需要四次操作
2. 所以时间复杂度为：O(h)，h：二叉树的高度
3. 如果二叉树退化为链表（经过一些添加删除操作），那么该树查找的时间复杂度会降低为 O(n)，n：二叉树的size

## 二、平衡二叉树

### 1. 平衡

* 当节点数量固定时，左右子树的高度越接近，这棵二叉树就越平衡（高度越低）

### 2. 理想平衡

* 就像完全二叉树、满二叉树，高度最小

### 3. 二叉搜索树怎么平衡

1. 因为节点的添加和删除时随机的，所以我们可以在节点添加、删除之后，想办法让二叉搜索树恢复平衡（减小树的高度）
2. 过多的调整会增加时间复杂度
3. 比较合理的方案是：用**尽量少**的调整次数达到**适度平衡**
   * 适度平衡的二叉搜索树被称为平衡二叉搜索树

### 4. 常见的平衡二叉搜索树

1. `AVL`树
   * Windows NT 内核中广泛使用
2. 红黑树
   * `C++STL`：map、set
   * `Java`：`TreeMap`、`TreeSet`、`HashMap`、`HashSet`
   * Linux 的进程调度
3. 一般也称其为：自平衡二叉搜索树

## 三、`AVL`树

#### 1. 基本概念

1. 平衡因子
   
   * 某节点左右子树的高度差
   
2. `AVL`树的特点
   1. 每个节点的平衡因子只可能是 **1**、**0**、**-1**（绝对值 <= 1，否则就是失衡）
   2. 搜索、添加、删除的时间复杂度是`O(logn)`
   
3. 平衡与非平衡的对比

   ![平衡与非平衡的对比](https://i.loli.net/2020/10/09/G8RKATqX7wChHDt.png)

#### 2. 继承结构

![继承结构](https://i.loli.net/2020/10/09/GtV6drejF1hPTxv.png)

1. 接口 `BinaryTree` 定义了二叉树应该有的一些方法
2. 类 `AbstractBinaryTree` 封装了二叉树方法的一些通用实现
3. 类 `BinarySearchTree` 是二叉搜索树的实现，还提供了 `addAfter(TreeNode<E> node)` 和 `removeAfter(TreeNode<E> node)` 以供扩展
4. `AVL`树和红黑树有自己独特定义的节点，但是添加删除的逻辑是一样的，仅仅是添加删除后的处理不一样
5. `AVL`树和红黑树有自己独特定义的节点都继承自 `TreeNode<E>`

#### 3. 实现分析

##### 1）失衡

1. **LL——右旋转（单旋）**

   ![LL](https://i.loli.net/2020/10/09/84EHNZmTQ5AkypG.png)

   * 如果添加或删除节点后出现图示情况，我们将该子树右旋转：

     1. `g.left = p.right`
     2. `p.right = g`
     3. 让p成为这颗子树的根节点
     4. 该子树会达到平衡
     5. 要注意维护 `T2`、`p`、`g`的 `parent` 属性，先后更新 g、p 的高度

   * 旋转后：

     ![右旋转](https://i.loli.net/2020/10/09/KLBjgIwODlpWn87.png)

2. **RR——左旋转（单旋）**

   ![RR](https://i.loli.net/2020/10/09/4CfyETbePQcp6nD.png)

   * 如果添加或删除节点后出现图示情况，我们将该子树左旋转：

     1. `g.right = p.left`
     2. `p.left = g`
     3. 让p成为这棵树的根节点
     4. 该子树会达到平衡
     5. 要注意维护 `T1`、`p`、`g`的 `parent` 属性，先后更新 g、p 的高度

     ![RR旋转](https://i.loli.net/2020/10/09/4jyBzUptDKEYx3P.png)

3. **LR——RR左旋转，LL右旋转（双旋）**

   ![LR](https://i.loli.net/2020/10/09/YF8mUW4XQIl2Hsx.png)

   * 如果添加或删除节点后出现图示情况，我们将p子树左旋转，再将g子树右旋转：

     1. 先将P子树左旋转：

        ![LL右旋转](https://i.loli.net/2020/10/09/2oMqal8LD4c9iRr.png)

     2. 再将g子树右旋转：

        ![RR](https://i.loli.net/2020/10/09/yCOz7e6lpMcPdsU.png)

4. **RL——LL右旋转，RR左旋转（双旋）**

   ![RL](https://i.loli.net/2020/10/09/jrOXPQMtbUImcZ2.png)

   * 如果添加或删除节点后出现图示情况，我们将p子树右旋转，再将g子树左旋转：

     1. p子树右旋转：

        ![](https://i.loli.net/2020/10/09/nHilCsgQohI12DX.png)

     2. g子树左旋转：

        ![](https://i.loli.net/2020/10/09/s27cdbFBqWUA1jP.png)

##### 2）可以导致失衡的条件

1. 添加：
   * 添加可能导致树失衡，最坏的节点是可能会导致所有的祖先节点都失衡
   * 父节点、非祖先节点是不可能失衡的
   * 添加到指的失衡只需要恢复高度最低的失衡节点就可以使整棵树恢复平衡
2. 删除：
   * 可能会导致父节点或祖先节点失衡（只有一个节点会失衡）
   * 恢复平衡后可能会带来连锁反应：恢复平衡后的父节点或祖先节点可能会失衡
   * 最坏的情况需要`O(logn)`次调整

##### 3）时间复杂度

* 搜索：`O(logn)`
* 添加：`O(logn)`，需要`O(1)`次的旋转操作
* 删除：`O(logn)`，最多需要`O(logn)`次的旋转操作

### 4. 补充

* AVL树代码：[AVLTree](https://github.com/ann-zhgy/inner-strength/tree/master/data-structure/src/main/java/cn/ann/part01/_06binary/tree/balance/AVLTree.java)

