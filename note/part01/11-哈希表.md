# 哈希表

## 一、是什么？

### 1. 先看一个场景：

* 设计一个写字楼通讯录，存放所有的公司的通讯信息
* 座机号作为key（假设座机号长度为8位），公司详情（名称、地址等）作为 value
* 添加、删除、搜索的时间复杂度要求为`O(1)`

### 2. 我们马上就能想到的方案是使用数组存取，座机号作为索引，数组里面存放公司详情。但是，有什么缺点？

* 空间复杂度非常大
* 空间利用率非常低，非常浪费内存空间

### 3. **哈希表**

1. 哈希表又称为散列表
2. 添加、搜索、删除的流程都是类似的
   1. 利用hash函数生成key对应的index
   2. 根据index定位操作的数组元素`O(1)`

3. 哈希表是**空间换时间**的典型应用

4. 哈希表内部的数组元素在很多地方也被叫做**bucket**（桶），整个数组被叫做**buckets**或**bucket array**

## 二、哈希函数

### 1. 哈希函数：

* 生成的hash值必须是整数
* 通过hash值与数组的长度进行运算，生成数组的索引值
  * hash值 & 数组的长度（要求数组的长度是2的n次幂）

### 2. 一个好的哈希函数在生成hash值的时候可以让每一个属性都参与计算，从而使得哈希值更加均匀的分布

* Java中，`HashMap` 的Key必须实现 `hashCode()` 和 `equals()` 方法，允许 key 为 null
  
* key 可以是整数、浮点数、字符串、自定义对象

* 不同种类的key，哈希值的生成方式不同，但是目的是一样的：让每个 key 的hash值尽量唯一
  
  1. 整数（int、char）：

     * 整数值就是hash值

     * ```java
       public static int hashCode(int value) {
           return value;
       }
       ```
    
  2. 浮点数（float、double）：

     * 将存储的二进制格式转为整数值（32bit）
     
     * ```java
       public static int hashCode(float value) {
           return floatToIntBits(value);
       }

       // 将64位二进制进行（前32位和后32位进行异或）运算生成整数值
       // >>>：无符号右移
       // ^：异或
       public static int hashCode(double value) {
           long bits = doubleToLongBits(value);
           return (int)(bits ^ (bits >>> 32));
       }
       ```

  3. 长整型（long）：

     * 将64位二进制进行（前32位和后32位异或）运算生成整数值

     * ```java
       public static int hashCode(long value) {
           return (int)(value ^ (value >>> 32));
       }
       ```

  4. 布尔（boolean）：

     * true ：1231； false ：1237

     * ```java
       public static int hashCode(boolean value) {
           return value ? 1231 : 1237;
       }
       ```

  5. 字符串（String）：

     * 解析：

       1. 如 $5369 = 5 * 10^3 + 3 * 10^2 + 6 * 10^1 + 9 = ((5 * 10 + 3) * 10 + 6) * 10 + 9$
       2. 对于字符串来说，也可以对其中的字符进行此操作，如：`JACK`
          * $hash = ((J * 31 + A) * 31 + C) * 31 + K$

     * ```java
       public int hashCode() {
           int h = hash;
           // value 是String底层的字符数组
           if (h == 0 && value.length > 0) {
               char val[] = value;

               for (int i = 0; i < value.length; i++) {
                   h = 31 * h + val[i];
               }
               hash = h;
           }
           return h;
       }
       ```

     * 为什么选择31？

       1. 对于符合 $2^n - 1$ 的数，$i * (2^n - 1) = i * 2^n - i = (i << n) - i$ ，而对于计算机来说，左移右移运算比乘除快得多
       2. 质数相乘的结果比其他数更容易产生唯一性
       3. 符合 $2^n - 1$ 的质数有 7，31，127……而31应该是甲骨文公司观察多次测试结果之后的选择  

  6. 自定义对象的hash方法
     * 解析：
       1. 重写 `hashCode()` 时，我们可以参照String的实现，计算出每个属性的哈希值，然后乘31就好

     * 哈希值太大怎么办？

       * 不用处理

## 三、`HashMap` 的一些细节

### 1) 重写 `hashCode()` 和 `equals()` 的作用

1. `hashCode()`：用来计算哈希值，然后通过hash值来计算索引
2. `equals()`：用来比较对象是否相等，实现key的唯一性

### 2) `HashMap` 中对哈希值的进一步处理

* ```java
  static final int hash(Object key) {
      int h;
      return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
  }
  ```

* 扰动计算，使哈希值分布更平均，尽可能的减少哈希冲突

### 3）key怎么比较

1. 优先使用**哈希值**比较，哈希值不同时，直接返回比较结果就好了
2. 如果哈希值相同，就判断是否是同一个对象，认为相等
3. 如果不是同一个对象，就使用内存值进行比较：`System.identityHashCode(key) - System.identityHashCode(node.key)`

### 4）哈希冲突：哈希值相同

1. 哈希冲突可能会带来什么问题？

   * 当向 `HashMap` 中插入元素时，可能会发生插入相同的key。

   * 从 `HashMap` 中取出元素时，可能取出null值。

2. 怎么解决？

   * 当遇到哈希值相同的情况时，需要遍历并比较**所有哈希值相同**的key

### 5）装填因子（LOAD_FACTOR）

1. 装填因子计算公式：元素数量 / 桶数组长度
2. 在Java 8的 `HashMap` 中，如果装填因子超过0.75，桶数组就扩容为原来的2倍

## 四、`TreeMap` VS `HashMap`

* 什么时候选择 `TreeMap` ?
  * 元素具备可比较性且要求升序遍历（按照元素从小到大或从大到小）
* 什么时候选择 `HashMap` ?
  * 无序遍历

