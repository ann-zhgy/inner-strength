# 红黑树

## 1. 什么是红黑树

1. 红黑树是一种自平衡二叉搜索树

   * 以前也叫做二叉平衡B树——红黑树可以完全等价于**四阶B树**，即**2-3-4树**

2. 红黑树必须满足以下五条性质

   1. 节点是**<font style="color: red;">RED</font>**或**BLACK**
   2. 根节点是**BLACK**
   3. 叶子节点（外部节点，空节点）都是**Black**
   4. **<font style="color: red;">RED</font>**节点的子节点都是**BLACK**
      * **<font style="color: red;">RED</font>**节点的子节点都是**BLACK**
      * 从根节点到叶子节点的所有路径上不能有2个连续的**<font style="color: red;">RED</font>**节点
   5. 从任一节点到叶子节点的 有路径都包含相同数目**BLACK**节点

3. 为什么在这些规则下，就可以保证平衡？

   ……

## 2. 红黑树的等价变换

1. 红黑树和**4阶B树（2-3-4树）**具有等价性

2. **BLACK** 节点与它的 **RED** 子节点融合在一起，形成 1个B树节点

3. 红黑树的 **BLACK** 节点个数与4阶B树的节点总个数相等

   ![RB-B](https://i.loli.net/2020/10/13/qvb2QN3nMdhutKZ.png)

## 3. 几个注意的地方

1. 几个英文单词
   1. parent ：父节点
   2. sibling ：兄弟节点
   3. uncle ：叔父节点（parent 的兄弟节点）
   4. grand ：祖父节点（parent 的父节点）

2. 一些辅助函数

   ![1](https://i.loli.net/2020/10/12/dwTzOMtZSREfn47.png)

   ![2](https://i.loli.net/2020/10/12/9uzR1Yh3tnF6rZx.png)

## 4. 红黑树的操作

### 1. 添加

> 建议新添加的节点默认为 **<font style="color: red;">RED</font>**，这样可以让红黑树的性质尽快满足（性质1、2、3、5都可以满足，性质4不一定）

* **添加的几种情况**

  ![红黑树添加的情况](https://i.loli.net/2020/10/13/dwNoK2x4lh3Fnqg.png)

  1. 添加的是根节点，或者是上溢到了根节点

  2. 有 4 种情况直接满足红黑树的性质4：`parent` 为 **BLACK**

     * 同样满足4阶B树的性质：

     即：向：46 左子节点、76 右子节点、88 子节点 位置插入节点

  3. 有 8 种情况不满足红黑树的性质4：`parent` 为 **<FONT style="color: red;">RED</FONT>**，其中：

     1. 有四种仅仅是双红

        向 50 和 72 的子节点位置插入节点

     2. 有 4 种属于B树节点上溢：

        向 17 和 33 的子节点位置插入节点

* **添加的各种情况的解决**

  1. 直接将节点染黑即可

  2. 不需要做任何操作

  3. 双红：

     1. 判定条件：叔父节点为黑色

        1. LL || RR

           > LL 与 `AVLTree` 的类似，如果插入的节点的父节点是祖父节点的左子节点，并且插入节点是父节点的左子节点，就是 LL，其他类似

           1. `parent` 染黑，`grand` 染红
           2. `grand` 进行旋转操作，使 `parent` 成为该子树的根节点即可 
              * RR: 50 添加右子节点 ---> 50 左旋
              * LL: 72 添加左子节点 ---> 72 右旋

        2. LR || RL

           1. 自己染成 **BLACK**，`grand` 染 **<FONT style="color: red;">RED</FONT>**
           2. 进行双旋操作，使自己成为该子树的根节点即可
              1. LR: 72 添加右子节点 ---> 72 左旋，76 右旋
              2. RL: 50 添加左子节点 ---> 50 右旋，46 左旋

     2. 判定条件：叔父节点为红色

        1. 将 `parent` 和 `uncle` 染成 **BLACK**
        2. 将 `grand` 染红，当作新添加的节点向上合并
           * **注意：**`grand` 向上合并时，可能会引起他的父节点继续上溢；若上溢持续到根节点，只需要将根节点染成 **BLACK** 即可


### 2. 删除

> B树删除时，如果删除的节点有子节点，会找到其前驱节点或后继节点替换元素，然后删除前驱或后继位置的那个节点，即：最后真正被删除的元素都在叶子节点中

* **删除的几种情况**

  ![红黑树删除](https://i.loli.net/2020/10/13/7zejucmiZkaOyUx.png)

  1. 删除 **<FONT style="color: red;">RED</FONT>** 子节点
  2. 删除 **BLACK** 子节点
     1. 拥有两个 **<FONT style="color: red;">RED</FONT>** 子节点
     2. 拥有一个 **<FONT style="color: red;">RED</FONT>** 子节点
     3. 删除会导致B树节点下溢
        1. 兄弟节点有元素借给我
        2. 兄弟节点没有元素借给我

* **删除的几种情况的处理**

  1. 直接删除即可

  2. 性质改变：

     1. 不可能会直接删除，因为它会找个子节点代替删除，不用考虑这种情况

     2. 将代替的子节点染成黑色即可保持性质

        ![remove 2-2](https://i.loli.net/2020/10/13/94qw72QtyMdjKY3.png)

     3. 删除 **BLACK** 叶子节点

        1. 兄弟节点为 **BLACK** 有 **<FONT style="color: red;">RED</FONT>** 子节点

           1. 进行旋转操作
           2. 旋转之后中心节点继承 `parent` 的颜色
           3. 旋转之后左右节点染成 **BLACK**

           ![remove 3-1-1](https://i.loli.net/2020/10/13/Dvhza8BrQktiVXL.png)

           ![remove 3-1-2](https://i.loli.net/2020/10/13/7BejIbfO1DcCvZJ.png)

           ![remove 3-1-3](https://i.loli.net/2020/10/13/UQtLfAcxX7rvVlT.png)

        2. 兄弟节点为 **BLACK** 没有 **<FONT style="color: red;">RED</FONT>** 子节点

           1. 将 兄弟 染成  **<FONT style="color: red;">RED</FONT>**，`parent` 染成 **BLACK** 即可修复红黑树的性质

              ![remove 3-2-1](https://i.loli.net/2020/10/13/pfTrsg6hnjEct12.png)

           2. 如果 `parent` 为 **BLACK**，会导致 `parent` 下溢，此时只需要将 `parent` 当作被删除节点处理即可

              ![remove 3-2-2](https://i.loli.net/2020/10/13/DNcydkTfwCEYvbM.png)

        3. 兄弟节点为 **<FONT style="color: red;">RED</FONT>**

           * 将兄弟节点染成 **BLACK**，`parent` 染成  **<FONT style="color: red;">RED</FONT>**，进行旋转
           * 于是回到了兄弟节点是 **BLACK** 的情况

           ![remove 3-3-1](https://i.loli.net/2020/10/13/QpHrKYagwFOd1At.png)![remove 3-3-2](https://i.loli.net/2020/10/13/hR1sGwF8qJCzBgI.png)

## 5. 红黑树的平衡

1. 为什么那5条性质可以保证红黑树平衡？

   * 那5条性质，可以保证红黑树等价于4阶B树

2. 相比AVL树，红黑树的平衡标准比较宽松：没有一条路径会大于其他路径的2倍

   ![red-black-tree balance](https://i.loli.net/2020/10/13/Oi9JHaQXwLPnpbt.png)

   1. 是一种弱平衡、黑高度平衡
   2. 红黑树的最大高度是`2 ∗ log2(n + 1)` ，依然是`O(logn)` 级别

3. 平均时间复杂度：

   1. 搜索：`O(logn)`
   2. 添加：`O(logn)`，`O(1)` 次的旋转操作
   3. 删除：`O(logn)`，`O(1)` 次的旋转操作

   * **注意：**据统计，红黑树的上溢和下溢的传递所引发的旋转操作最多有三层

## 6. AVL树 VS 红黑树

* AVL树
  * 平衡标准比较严格：每个左右子树的高度差不超过1
  * 最大高度是`1.44 ∗ log2(n + 2) − 1.328`（100W个节点，AVL树最大树高28）
  * 搜索、添加、删除都是 `O(logn)` 复杂度，其中添加仅需 `O(1)` 次旋转调整、删除最多需要 `O(logn)` 次旋转调整
* 红黑树
  * 平衡标准比较宽松：没有一条路径会大于其他路径的2倍
  * 最大高度是 `2 ∗ log2(n + 1)`（ 100W个节点，红黑树最大树高40）
  * 搜索、添加、删除都是 `O(logn)` 复杂度，其中添加、删除都仅需 `O(1)` 次旋转调整

* 总结：
  * 搜索的次数远远大于插入和删除，选择AVL树；搜索、插入、删除次数几乎差不多，选择红黑树
  * 相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树
  * 红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树

## 7. 补充

1. 红黑树代码：[code](https://github.com/ann-zhgy/inner-strength/tree/master/data-structure/src/main/java/cn/ann/part01/_06binary/tree/balance/RedBlackTree.java)

2. 更新了继承结构

   ![继承结构](https://i.loli.net/2020/10/14/Xpf346Q25iUnNst.png)
   1. `BinarySearchTree<E>` 中添加了 `TreeNode<E> createNode(E element, TreeNode<E> parent)` 方法，执行添加操作时，会调用这个方法进行调用
   2. `AbstractBalancedBinaryTree<E>` 抽取了`AVLTree` 和 `RedBlackTree` 都需要用到的旋转操作的相关代码