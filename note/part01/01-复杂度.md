# 一、数据结构

* 数据结构就是计算机存储、组织数据的方式，常见的数据结构可以分为：
  * 线性结构、树形结构、图形结构
* 在实际应用中，要根据使用场景来选择最合适的数据结构

## 1. 什么是算法

* 算法是用于解决特定问题的一系列执行步骤

  ```java
  // 计算 a 和 b 的和
  public static int plus(int a, int b) {
      return a + b;
  }
  
  // 计算 1 + 2 + 3 + 4 + ... + n 的和
  public static int sum(int n) {
      int sum = 0;
      for (int i = 0; i < n; i++) {
          sum += i;
      }
      return sum;
  }
  ```

* 只要能解决问题，就是算法，但是使用不同的算法解决同一个问题，效率相差可能会非常大

* 比如：求第n个斐波那契数（Fibonacci Number）

  ```java
  // 使用递归方式实现
  public static long fibonacciRecurse(int n) {
      if (n < 0) throw new RuntimeException("无效参数");
      if (n <= 1) return n;
      return fibonacciRecurse(n - 1) + fibonacciRecurse(n - 2);
  }
  
  // 使用循环的方式实现
  public static long fibonacciFor(int n) {
      if (n < 0) throw new RuntimeException("无效参数");
      if (n <= 1) return n;
      long frist = 0, second = 1;
      for (int i = 0; i < n - 1; i++) {
          long sum = frist + second;
          frist = second;
          second = sum;
      }
      return second;
  }
  
  public static void main(String[] args) {
      Times.test("fibonacciFor", () -> System.out.println(fibonacciFor(50)));
      Times.test("fibonacciRecurse", () -> System.out.println(fibonacciRecurse(50)));
  }
  ```

  运行结果：

  ```tex
  【fibonacciFor】
  开始：2020-08-29 14:48:37
  12586269025
  结束：2020-08-29 14:48:37
  耗时：0豪秒-------------------------------------
  【fibonacciRecurse】
  开始：2020-08-29 14:48:37
  12586269025
  结束：2020-08-29 14:49:53
  耗时：76114豪秒-------------------------------------
  ```

## 2. 怎么评判算法的好坏？

* 算法有好有坏，仅凭运算的时间来评判是不合适的，毕竟运行环境也不可能一样
* 所以我们引入了评判算法好坏的标准

### 1）正确性、可读性、健壮性

* 这三点要求算法必须得到正确的结果，也要容易阅读，还要有对不合理输入的处理能力

### 2）复杂度

* 评判算法的复杂度分为**时间复杂度**和**空间复杂度**
  1. 时间复杂度：估算程序指令的执行次数（执行时间）
  2. 空间复杂度：估算所需占用的存储空间

* 一般使用**大O表示法**来描述复杂度，表示的是数据规模 n 对应的复杂度

* 忽略常数、系数、低阶

  * 9 >> O(1)

  * 2n + 3 >> O(n)

  * n<sup>2</sup> + 2n + 3 >> O(n<sup>2</sup>)

  * log<sub>2</sub>n、log<sub>9</sub>n >> logn

  * 写法上，n<sup>3</sup> 等价于 n^3

    > 注意：大O表示法仅仅是一种粗略的分析模型，是一种估算，能帮助我们短时间内了解一个算法的执行效率

* 常见的复杂度

  |                  执行次数                   |      复杂度      | 非正式术语 |
  | :-----------------------------------------: | :--------------: | :--------: |
  |                     12                      |       O(1)       |   常数阶   |
  |                   2n + 3                    |       O(n)       |   线性阶   |
  |           4n<sup>2</sup> + 2n +3            | O(n<sup>2</sup>) |   平方阶   |
  |           4log<sub>2</sub>n + 25            |     O(logn)      |   对数阶   |
  |        3n + 2nlog<sub>3</sub>n + 15         |     O(nlogn)     |  nlogn阶   |
  | 4n<sup>3</sup> + 3n<sup>2</sup> + 22n + 100 | O(n<sup>3</sup>) |   立方阶   |
  |                2<sup>n</sup>                | O(2<sup>n</sup>) |   指数阶   |

  O(1) < O(logn) < O(n) < O(nlogn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

* 斐波那契程序中，`fibonacciFor` 的时间复杂度为 O(n)，`fibonacciRecurse` 的时间复杂度为 O(2<sup>n</sup>)

## 3. 算法优化要怎么优化？

* 尽量减少时间复杂度
* 尽量减少空间复杂度
* 在适合的情况下，以空间换取时间，或者是以时间换取空间

## 4. 待续

1. 最好、最坏复杂度

2. 均摊复杂度

3. 复杂度震荡

4. 平均复杂度

5. ###### ……



