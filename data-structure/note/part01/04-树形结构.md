# 树形结构——实现：二叉树

## 一、二叉搜索树

### 1. 数据结构

```java
public abstract class AbstractBinaryTree {
    protected int size;
    protected Node<E> root;
    protected Comparator<E> comparator;

    protected static class Node<E> {
        E element;
        Node<E> parent;
        Node<E> left;
        Node<E> right;

        Node(E element, Node<E> parent) {
            this.element = element;
            this.parent = parent;
        }
    }
}
```

* 所有的二叉树都应该有这样结构
* 因为是有序树，所以我们需要传一个比较器(Comparator&lt;E&gt;)，或者泛型本身就需要提供用来比较的方法(实现 Comparable&lt;E&gt; 接口)

### 2. 接口设计

```java
public interface BinaryTree<E> {
    int size();	// 元素的数量
    boolean isEmpty();	// 是否为空
    void clear();	// 清空所有元素
    void add(E element);	// 添加元素
    void remove(E element);	// 删除元素
    boolean contains(E element);	// 是否包含某元素
    void travarsal(Visitor<E> visitor); // 遍历树，默认使用前序遍历
}

public interface Visitor<E> {
    /**
     * 因为不知道遍历方法的调用者要怎么操作元素，所以提供接口（策略模式）
     *
     * @param element elem
     * @return true：继续遍历 | false：结束遍历
     */
    boolean visit(E element);
}
```

* 这是我们应该实现的基本功能
* 需要注意的是：我们现在使用的二叉树是没有索引的

### 3. 实现细节

* [BinarySearchTree](https://github.com/ann-zhgy/inner-strength/tree/master/data-structure/src/main/java/cn/ann/part01/_06binary/tree/BinarySearchTree.java)

#### 1）添加 &gt; `add()`：

1. 如果根节点为空，就添加到根节点
2. 添加节点之前，我们需要找到我们要插入的节点的位置，然后再执行插入操作

* **注意：在进行比较时，我们优先使用传入的比较器比较**

#### 2）遍历 &gt; `traversal()`：

1. 前（先）序遍历  &gt; `preorderTraversal()`：

   访问顺序：根节点、前（先）序遍历左子树、前（先）序遍历右子树

   ![前序遍历](https://i.loli.net/2020/10/09/RkLyc9F1n3grb4U.png)

   1. 递归实现

      ```java
      void preorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
          if (node == null) {
              return;
          }
          visitor.visit(node.element);
          preorderTravarsal(node.left, visitor);
          preorderTravarsal(node.right, visitor);
      }
      ```

   2. 非递归实现

      * 前序遍历属于深度优先遍历，使用的是 循环 + 栈

      ```java
      void preorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
          Stack<TreeNode<E>> stack = new Stack<>();
          TreeNode<E> curr = node;
          // 因为前序遍历最后访问的一定是右子节点，所以可以使用这个条件
          // 当弹出最后一个节点后，curr = curr.right 可以保证 curr = null
          while (curr != null || !stack.isEmpty()) {
              while (curr != null) {
                  if (!visitor.visit(curr.element)) {
                      return;
                  }
                  stack.push(curr);
                  curr = curr.left;
              }
              if (!stack.isEmpty()) {
                  curr = stack.pop();
                  curr = curr.right;
              }
          }
      }
      ```

2. 中序遍历 &gt; `inorderTraversal()`：

   访问顺序：中序遍历左子树、根节点、中序遍历右子树

   ![中序遍历](https://i.loli.net/2020/10/09/GkNCJwYiMtLAZFz.png)

   1. 递归实现

      ```java
      void inorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
          if (node == null) {
              return;
          }
          inorderTravarsal(node.left, visitor);
          visitor.visit(node.element);
          inorderTravarsal(node.right, visitor);
      }
      ```

   2. 非递归实现

      ```java
      void inorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
          Stack<TreeNode<E>> stack = new Stack<>();
          TreeNode<E> curr = node;
          while (curr != null || !stack.isEmpty()) {
              while (curr != null) {
                  stack.push(curr);
                  curr = curr.left;
              }
              if (!stack.isEmpty()) {
                  curr = stack.pop();
                  if (!visitor.visit(curr.element)) {
                      return;
                  }
                  curr = curr.right;
              }
          }
      }
      ```

3. 后序遍历 &gt; `postorderTraversal()`：

   访问顺序：后序遍历左子树、后序遍历右子树、根节点

   ![后序遍历](https://i.loli.net/2020/10/09/hgLMZBu6r1TqHwo.png)

   1. 递归实现

      ```java
      void postorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
          if (node == null) {
              return;
          }
          preorderTravarsal(node.left, visitor);
          preorderTravarsal(node.right, visitor);
          visitor.visit(node.element);
      }
      ```

   2. 非递归实现

      1. 节点中有是否已经访问过的标记：`isVisited`

         ```java
         void postorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
             Stack<TreeNode<E>> stack = new Stack<>();
             TreeNode<E> curr = node;
             while (curr != null) {
                 // 走到curr节点下的最左端
                 while (curr != null && !curr.isVisited) {
                     stack.push(curr);
                     curr = curr.left;
                 }
                 // 栈非空
                 if (!stack.isEmpty()) {
                     curr = stack.peek();
                     // 当前节点被访问的前提是 没有右子树 或 右子树被访问过
                     if (curr.right != null && !curr.right.isVisited) {
                         curr = curr.right;
                     } else {
                         curr = stack.pop();
                         if (!visitor.visit(curr.element)) {
                             return;
                         }
                         curr.isVisited = true;
                     }
                 } else { // 如果栈空，跳出循环
                     // 注意，这个不能写到上面的 while 循环的上面，因为第一次循环进来栈就是空的
                     break;
                 }
             }
         }
         ```

      2. 节点中没有是否已经访问过的标记

         ```java
         void postorderTravarsal(TreeNode<E> node, Visitor<E> visitor) {
             Stack<TreeNode<E>> stack = new Stack<>();
             TreeNode<E> curr = node;
             TreeNode<E> lastVisitNode = null;
             // 走到二叉树的最左端（压栈）
             while (curr != null) {
                 stack.push(curr);
                 curr = curr.left;
             }
             while (!stack.isEmpty()) {
                 curr = stack.peek();
                 // 当前节点有右子树，并且右子树没有被访问过（右节点不是上次访问的节点）
                 if (curr.right != null && curr.right != lastVisitNode) {
                     // 走到右子树的最左端（将右子树压进栈）
                     curr = curr.right;
                     while (curr != null) {
                         stack.push(curr);
                         curr = curr.left;
                     }
                 } else {
                     // 当前节点可以被访问
                     curr = stack.pop();
                     if (!visitor.visit(curr.element)) {
                         return;
                     }
                     // 更新上次访问的节点为此节点
                     lastVisitNode = curr;
                 }
             }
         }
         ```

* **注意：**
  1. 使用递归遍历树时，如果想要根据用户返回的信息决定是否跳出循环，需要让 `Visitor` 存储跳出循环的标记，这就意味着 `Visitor` 只能是抽象类，不能是接口
  2. 后序遍历比前序遍历和中序遍历难理解一些，因为根节点的使用时机不同，同时就意味着结束循环的条件不同，推荐多看看代码吧

#### 3）计算树的高度  &gt; `height()`：

1. 递归：当前节点的高度 = 左子树和右子树的最大高度 + 1

   ```java
   int height(TreeNode<E> node) {
       if (node == null) {
           return 0;
       }
       return 1 + Math.max(height(node.left), height(node.right));
   }
   ```

2. 非递归：使用循环 + 队列，假设我们当前遍历的是第 i 层，当我们遍历完第 i 层之后，队列中的元素数量就是 i + 1 层的结点的数量

   ```java
   int height(TreeNode<E> node) {
       if (node == null) {
           return 0;
       }
   
       int height = 0;
       int levelSize = 1;
       Queue<TreeNode<E>> queue = new ArrayDeque<>();
       queue.offer(node);
       while (!queue.isEmpty()) {
           TreeNode<E> treeNode = queue.poll();
           levelSize--;
           if (treeNode.left != null) {
               queue.offer(treeNode.left);
           }
           if (treeNode.right != null) {
               queue.offer(treeNode.right);
           }
   		// 当 levelSize == 0 时，就代表着我们遍历完了一层
           if (levelSize == 0) {
               height++;
               levelSize = queue.size();
           }
       }
       return height;
   }
   ```

#### 4）判断是否为完全二叉树 &gt; `isComplete()`：

* 实现思路：使用层序遍历

  1. 如果 `node.left == null && node.right != null`，代表不是完全二叉树
  2. 如果 `node.left ！= null && node.right == null`，或者 `node` 是叶子节点，代表后面所有的节点都必须是叶子节点才是完全二叉树

  ```java
  boolean isComplete() {
      if (root == null) {
          return false;
      }
      Queue<TreeNode<E>> queue = new ArrayDeque<>();
      queue.offer(root);
      boolean isLeaf = false;
      while (!queue.isEmpty()) {
          TreeNode<E> treeNode = queue.poll();
          if (isLeaf && !treeNode.isLeaf()) {
              return false;
          }
          if (treeNode.left != null) {
              queue.offer(treeNode.left);
          } else if (treeNode.right != null) {
              return false;
          }
          if (treeNode.right != null) {
              queue.offer(treeNode.right);
          } else {
              // right == null
              isLeaf = true;
          }
      }
      return true;
  }
  ```

#### 5）前驱节点、后继节点：为删除做准备

1. 前驱结点：**中序遍历**时的前一个结点

   ![predecessor](https://i.loli.net/2020/10/09/ZLvpJQiS3g2kaIT.png)

   * 获取 8 的前驱结点（7）：因为 8 有左子树，所以前驱结点是它的左子树的最右边的节点：`node.left.right.right`
   * 获取 11 的前驱结点（10）：因为 11 没有左子树。所以前驱结点一定是（祖）父节点，且（祖）父节点一定是其父节点的左子节点：`node.parent && node.parent != node.parent.left`
   * 没有前驱结点：1 和没有左子树的根节点

   ```java
   TreeNode<E> predecessor(TreeNode<E> node) {
       if (node == null) {
           return null;
       }
       TreeNode<E> result = node.left;
       // 前驱结点在左子树中
       if (result != null) {
           while (result.right != null) {
               result = result.right;
           }
   
           return result;
       }
       // 前驱结点在父节点、祖父节点中中
       result = node;
       while (result.parent != null && result != result.parent.right) {
           result = result.parent;
       }
   
       // result.parent == null 没有前驱结点
       // result == result.parent.right 找到了前驱结点
       return result.parent;
   }
   ```

2. 后继节点：**中序遍历**时的后一个结点

   * 与前驱节点差不多的情况

   ```java
   TreeNode<E> successor(TreeNode<E> node) {
       if (node == null) {
           return null;
       }
       TreeNode<E> result = node.right;
       // 前驱结点在左子树中
       if (result != null) {
           while (result.left != null) {
               result = result.left;
           }
   
           return result;
       }
       // 前驱结点在父节点、祖父节点中中
       result = node;
       while (result.parent != null && result == result.parent.right) {
           result = result.parent;
       }
   
       // result.parent == null 没有前驱结点
       // result == result.parent.right 找到了前驱结点
       return result.parent;
   }
   ```

#### 6）删除节点 &gt; `remove()`：存在三种情况

1. 删除叶子节点：直接删除

2. 删除度为 1 的节点：用子节点替换当前节点

3. 删除度为 2 的节点：找到当前节点的前驱节点或后继节点，替换当前节点的值，然后删除找出来的节点

   * 找出来的前驱结点或后继节点一定是叶子节点或度为 1 的节点

   ```java
   void remove(E element) {
       if (element == null) {
           return;
       }
       TreeNode<E> node = search(element);
       if (node == null) {
           return;
       }
       size--;
       // 节点度为2
       if (node.left != null && node.right != null) {
           // 找出后继节点
           TreeNode<E> successorNode = successor(node);
           node.element = successorNode.element;
           // 之后删除后继节点就好了
           node = successorNode;
       }
       // 到此，node 的度一定是 1 或 0
       // 如果 node 度为 1，replace 为非空的那个节点，如果 node 度为 0，replace 为 null
       TreeNode<E> replace = node.left != null ? node.left : node.right;
       if (replace != null) { // 度为 1，有子节点，需要让子节点的 parent 指向父节点；如果没有子节点的话就不用管了
           replace.parent = node.parent;
       }
       if (node.parent == null) { // node 是根节点
           root = replace;
       } else { // node 不是根节点
           if (node == node.parent.left) {
               node.parent.left = replace;
           } else {
               node.parent.right = replace;
           }
       }
   }
   
   TreeNode<E> search(E element) {
       checkElement(element);
       try {
           TreeNode<E> result = root;
           while (result != null) {
               int compare = compare(element, result.element);
               if (compare == 0) {
                   return result;
               } else if (compare < 0) {
                   result = result.left;
               } else {
                   result = result.right;
               }
           }
       } catch (NoSuchMethodException e) {
           e.printStackTrace();
       }
       return null;
   }
   ```



